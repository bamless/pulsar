import io

// Error reporter interface
// The various error checking passes call `reportError` every time
// they encounter a problem
class ErrorReporter
    // @arg message A description of the error
    // @arg token   Token involved in the error
    fun reportError(message_, token_)
        raise NotImplementedException()
    end
end

// Implementation of error reporter that buffers the errors and
// delays the reporting until `reportErrors` is called
// On reporting, the errors are ordered by line
class BufferedReporter is ErrorReporter
    fun new()
        this._errors = []
    end

    fun reportError(message, token)
        this._errors.add((message, token))
    end

    fun formatError(message_, token_)
        raise NotImplementedException()
    end

    fun outputError(error_)
        raise NotImplementedException()
    end

    fun reportErrors()
        this._errors.sort(|e1, e2| => e1[1].line() - e2[1].line())
        for var message, token in this._errors
            var formatted = this.formatError(message, token)
            this.outputError(formatted)
        end
        this._errors.clear()
    end

    fun numErrors()
        return #this._errors
    end
end

// Error reporter that writes the errors to a file
// The ownership of the file passed upon construction is taken by the class,
// and thus it should be closed by calling the `close` method provided here
class FileReporter is BufferedReporter
    fun new(file)
        super()
        this._file = file
    end

    fun outputError(error)
        this._file.writeln(error)
    end

    fun close()
        if this._file != io.stderr and this._file != io.stdout
            this._file.close()
        end
    end
end

// Formats errors in a humal readable form
class PrettyReporter is FileReporter
    fun new(file)
        super(file)
    end

    fun formatError(message, token)
        var lineStart = token.line()
        var colStart = token.coloumn() - 1
        var colEnd = token.coloumnEnd() - 1
    
        var src = token.getSource()
        var line = src.getLine(lineStart)

        var errorBuilder = ["File {0} [line {1}]:\n" % (src.path, lineStart)]
        errorBuilder.add(line)
        errorBuilder.add("\n")
        for var i = 0; i < colStart; i += 1
            errorBuilder.add("\t" if line.charAt(i) == char("\t") else " ")
        end
        errorBuilder.add("^")
        errorBuilder.add("~" * (colEnd - colStart - 1))
        errorBuilder.add("\n")
        errorBuilder.add(message)

        return errorBuilder.join()
    end
end